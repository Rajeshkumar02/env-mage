/**
 * EnvJson Command
 * Generates a JSON structure from .env file with support for TypeScript interfaces
 */

import * as fs from 'fs';
import * as path from 'path';
import { parseEnvContent } from '../utils/envParser';
import { logger } from '../utils/logger';
import { detectValueType, convertStringToTypedValue, generateTypeScriptInterface } from '../utils/typeUtils';

interface Result {
  success: boolean;
  message: string;
}

interface EnvJsonOptions {
  envPath: string;
  outputPath: string;
  includeValues: boolean;
  typeOutput?: string;
  detectTypes: boolean;
  format: 'json' | 'esm' | 'commonjs';
}

/**
 * Generate a JSON structure from .env file
 * @param options Configuration options for the command
 * @returns Result object with success status and message
 */
export function envJsonCommand(options: Partial<EnvJsonOptions> = {}): Result {
  try {
    // Set default options
    const {
      envPath = '.env',
      outputPath = '.env.json',
      includeValues = false,
      typeOutput,
      detectTypes = false,
      format = 'json'
    } = options;

    // Resolve paths
    const resolvedEnvPath = path.resolve(process.cwd(), envPath);
    const resolvedOutputPath = path.resolve(process.cwd(), outputPath);
    let resolvedTypeOutputPath: string | undefined;
    
    if (typeOutput) {
      resolvedTypeOutputPath = path.resolve(process.cwd(), typeOutput);
    }

    // Check if .env file exists
    if (!fs.existsSync(resolvedEnvPath)) {
      return {
        success: false,
        message: `No ${envPath} file found. Run "env-mage init" first`,
      };
    }

    // Read and parse .env file
    const content = fs.readFileSync(resolvedEnvPath, 'utf8');
    const envVars = parseEnvContent(content);

    // Create structure for the output
    const jsonStructure: Record<string, any> = {};
    
    for (const [key, value] of Object.entries(envVars)) {
      if (!includeValues) {
        // If not including values, use null placeholders
        jsonStructure[key] = null;
      } else if (detectTypes) {
        // If detecting types, convert values to their appropriate types
        jsonStructure[key] = convertStringToTypedValue(value);
      } else {
        // Default: use string values
        jsonStructure[key] = value;
      }
    }
    
    // Generate output based on format
    let outputContent = '';
    switch (format) {
      case 'esm':
        outputContent = `// Generated by env-mage
export const env = ${JSON.stringify(jsonStructure, null, 2)};
`;
        break;
      case 'commonjs':
        outputContent = `// Generated by env-mage
module.exports = ${JSON.stringify(jsonStructure, null, 2)};
`;
        break;
      default:
        outputContent = JSON.stringify(jsonStructure, null, 2);
    }

    // Write to output file
    fs.writeFileSync(resolvedOutputPath, outputContent);
    
    // Generate TypeScript interface if requested
    if (resolvedTypeOutputPath) {
      const interfaceName = path.basename(resolvedTypeOutputPath, path.extname(resolvedTypeOutputPath))
        .replace(/[^a-zA-Z0-9_]/g, '_')
        .replace(/^[0-9]/, '_$&');
        
      const tsInterface = generateTypeScriptInterface(
        envVars, 
        interfaceName.charAt(0).toUpperCase() + interfaceName.slice(1) + 'Env', 
        detectTypes
      );
      
      fs.writeFileSync(resolvedTypeOutputPath, tsInterface);
      
      return {
        success: true,
        message: `✅ Created ${outputPath} with ${Object.keys(jsonStructure).length} keys and generated TypeScript interface at ${typeOutput}`,
      };
    }
    
    return {
      success: true,
      message: `✅ Created ${outputPath} with ${Object.keys(jsonStructure).length} keys`,
    };

    return {
      success: true,
      message: `✅ Created ${outputPath} with ${Object.keys(jsonStructure).length} keys`,
    };
  } catch (error) {
    logger.debug(`Error in envJson command: ${error}`);
    return {
      success: false,
      message: error instanceof Error ? error.message : 'Unknown error in envJson command',
    };
  }
}
